{"name":"Backbone.hoard","tagline":"XHR de-duping and configurable caching for Backbone.js","body":"[![Build Status](https://travis-ci.org/cmaher/backbone.hoard.svg?branch=master)](https://travis-ci.org/cmaher/backbone.hoard)\r\n\r\nbackbone.hoard\r\n--------------\r\n\r\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/cmaher/backbone.hoard?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nConfigurable caching for Backbone. Hoard is designed to make it easy to avoid \r\nextraneous AJAX requests by caching responses and making sure only one request goes out for the same url, \r\nall while remaining highly configurable and customizable. [Read about the reasoning behind Backbone.Hoard to find out if it's right for you](http://www.conductor.com/nightlight/using-backbone-hoard-spare-server-sanity/).\r\n\r\n#Installing\r\n\r\nHoard is available on npm and bower as `backbone.hoard`.\r\n\r\n```\r\nnpm install backbone.hoard\r\n\r\nOR\r\n\r\nbower install backbone.hoard\r\n```\r\n\r\nWhen using bower, `dist/backbone.hoard.js` should work for all environments.\r\n\r\n#Example\r\n```js\r\nvar cacheControl = new Backbone.Hoard.Control();\r\nvar MyModel = Backbone.Model.extend({\r\n    url: function () {\r\n        return '/my-models/' + this.id;\r\n    },\r\n    \r\n    sync: cacheControl.getModelSync()\r\n});\r\n\r\nvar model1 = new MyModel({ id: 1 });\r\nvar model2 = new MyModel({ id: 1 });\r\n\r\nvar fetches = [model1.fetch(), model2.fetch()];\r\n\r\nPromise.all(fetches).then(function () {\r\n    // model1 and model2 have the same attributes, returned from the endpoint\r\n    // Only one ajax request has been made\r\n    doStuff();\r\n});\r\n```\r\n\r\n#Requirements\r\n\r\n - Backbone 1.0.0 - 1.1.2\r\n - underscore 1.4.4 - 1.7.0\r\n - `localStorage`\r\n - An es6-compliant `Promise`\r\n \r\n#API\r\n\r\nThe usage demonstrated in the example represents the common use case. \r\nThat said, Hoard is about configuring caching behavior, and each component is open to customization.\r\n\r\n##Control\r\n\r\nThe `Control` is the entry point for all Hoard behavior. \r\nIt's primary purpose is to assemble a `Strategy` for each method accepted by Backbone.sync.\r\n\r\n###new Control(options)\r\n\r\nCreates a `Control` and overwrites the following default options, if provided\r\n\r\n- storeClass: the type of `Store` to create and assign to `store`, passed to all strategies\r\n- policyClass: the type of `Policy` to create and assign to `policy`, passed to all strategies\r\n- createStrategyClass: the type of `Strategy` to create and assign to `createStrategy`, used when `sync` is called with method `create`\r\n- readStrategyClass: the type of `Strategy` to create and assign to `readStrategy`, used when `sync` is called with method `read`\r\n- updateStrategyClass: the type of `Strategy` to create and assign to `updateStrategy`, used when `sync` is called with method `update`\r\n- deleteStrategyClass: the type of `Strategy` to create and assign to `deleteStrategy`, used when `sync` is called with method `delete`\r\n- patchStrategyClass: the type of `Strategy` to create and assign to `patchStrategy`, used when `sync` is called with method `patch`\r\n\r\nAll options provided will be passed down to the constructors of the `store`, `policy`, and all strategies.\r\n\r\n###Control#sync(method, model, options)\r\n\r\nDelegates to a strategy determined by `method`. Calls `Strategy#execute` with the provided `model` and `options`.\r\n\r\nReturns a `Promise` that resolves if the sync action is successful or rejects if it fails.\r\n\r\nBy default, Control#sync behaves differently depending on the `method` parameter, as follows:\r\n\r\n* `read`\r\n    * [Cache hit] If the given `model` has data in the cache\r\n        * If the item is not expired, call options.success with the cached item\r\n        * If the item is expired, remove the item from the cache, and proceed as a read [Cache Miss]\r\n    * [Cache Miss] If the given `model` does not have data in the cache\r\n        * On a success, store the result in the cache\r\n        * On an error, remove the `model`'s item from the cache\r\n        * While waiting for the result of the call to `Backbone.sync`, prevent subsequent requests to the same url \r\n        from being made. Update all models blocked in this way once the `sync` result is known.\r\n* `create`, `update`, `patch`\r\n    * Delegate to `Backbone.sync` and store the response in the cache\r\n* `delete`\r\n    * Remove the `model`'s item from the cache\r\n    * Delegate to `Backbone.sync`\r\n    \r\nAll interactions with the cache use the given `model`'s `url` property as th key, \r\nas resolved at time of the initial sync call\r\n\r\nNOTE: If at any time there is not enough space in the cache to store the desired item, Hoard will remove all \r\nmanaged items from the cache and try again. This behavior is temporary and is targeted for improvment in future releases.\r\n\r\n###Control#getModelSync\r\n\r\nReturns a method that can be assigned `sync` on a `Backbone.Model` or a `Backbone.Collection`. \r\nThe returned method has all of the same properties as the control's `sync` method.\r\n\r\n##Policy\r\n\r\nThe `Policy` determines meta information about cached items\r\n\r\n###Policy#timeToLive\r\n\r\nThe amount of time, in milliseconds, that an item should be stored in the cache\r\n\r\n###Policy#expires\r\n\r\nA timestamp, in milliseconds, indicating the time after which the item should no longer be stored in the cache. \r\nIf both `timeToLive` and `expires` are present, `expires` takes precedence.\r\n\r\n###Policy#getUrl(model, options, options)\r\n\r\nReturns an identifier for the given `model` and `method` to reference in the cache.\r\nDefaults to the result of `model.url`.\r\n\r\n###Policy#getKey(model, method, options)\r\n\r\nReturns an identifier for the given `model` and `method` to reference in the cache.\r\nDefaults to Policy#getUrl.\r\n\r\n###Policy#getData(model, options)\r\n\r\nReturn the database representation of the model. Defaults to `model.toJSON()`.\r\n\r\n###Policy#shouldEvictItem(metadata)\r\n\r\nReturns `true` if the item represented by `metadata` is stale, false otherwise.\r\n\r\n###Policy#getKeysToEvict(metadata, key, value, error)\r\n\r\nReturns an array of keys to evict from cache if the cache is full. Defaults to returning all keys in the cache.\r\n\r\n###Policy#getMetadata(key, response, [options])\r\n\r\nReturns an object representing the metadata for the given `key`, `response`, and `options`.\r\n\r\nBy default, only expiration data is returned, based on the Policy's `timeToLive` or `expires` property. \r\nThis behavior is agnostic of any arguments provided, which are available for custom implementations.\r\n\r\n##Strategy\r\n\r\nThe `Strategy` uses the `Store` and `Policy` to determines how to handle any given call to `sync`. It is responsible for\r\ndetermining when to read from the cache or from the server, when to write to the cache, \r\nand when to remove items from the cache.\r\n\r\n###Strategy#execute(model, options)\r\n\r\nDetermines how to handle a `sync` for the given `model`. The bulk of caching behavior is handled by various \r\nimplementations of this method in different subclasses of `Strategy`\r\n\r\nReturns a `Promise` that resolves if the sync action is successful or rejects if it fails.\r\n\r\n##Store\r\n\r\nThe `Store` encapsulates all interaction with the backing persistence API. \r\nEven though the default implementation uses `localStorage` for persistence, \r\nall interactions with `Store` are asynchronous. \r\nThis behavior makes it possible to use other types of client-side storage, such as IndexedDB or WebSQL\r\n\r\n###Store#get(key, [options])\r\n\r\nReturns a `Promise` that resolves with the cached item associated with the given `key` if it exists, \r\nor a rejected `Promise` if the item is not in the cache.\r\n\r\n`options` are provided for use by custom implementations.\r\n\r\n###Store#set(key, item, meta, [options])\r\n\r\nStore the given `item` in the cache under the given `key`. \r\nAdditionally, store the provided `metadata` containing information that Hoard needs to manage the cached item.\r\n\r\nReturns a `Promise` that resolves when the given item and metadata are stored\r\nor rejects if an error occurs when storing either value.\r\n\r\n`options` are provided for use by custom implementations.\r\n\r\n###Store#invalidate(key, [options])\r\n\r\nRemove the item and metadata associated with the given `key` from the cache.\r\n\r\nReturns a `Promise` that resolves when the item is removed from the cache.\r\n\r\n`options` are provided for use by custom implementations.\r\n\r\n###Store#getMetadata(key, [options])\r\n\r\nReturns a `Promise` that resolves with either the metadata associated with the given `key` \r\nor an empty object if no metadata is found.\r\n\r\n`options` are provided for use by custom implementations.\r\n\r\n#Configuration\r\n\r\nHoard uses reasonable defaults for it's external dependencies, but they can be configured, if desired.\r\n\r\n##Hoard.Promise\r\n\r\nHoard will use the native Promise (`window.Promise`) implementation, if it exists. \r\nOtherwise, you will need to configure Hoard with an es6-compliant Promise implementation.\r\n \r\n##Hoard.backend\r\n\r\nBy default, Hoard will use `localStorage` to cache data and metadata.\r\nIf support for older browsers is desired, be sure to use a polyfill. \r\n`Hoard.backend` can also be set to `sessionStorage`, or anything matching a `localStorage` API supporting:\r\n\r\n - `backend.setItem`\r\n - `backend.getItem`\r\n - `backend.removeItem`\r\n \r\n ```js\r\n // ex: using sessionStorage instead of local storage\r\n // Make Stores use sessionStorage unless explicitly told to use something else\r\n Hoard.backend = sessionStorage;\r\n \r\n // Make all instantces of LocalStore use localStorage\r\n var LocalStore = Hoard.Store.extend({ backend: localStorage });\r\n ```\r\n","google":"UA-38761388-2","note":"Don't delete this file! It's used internally to help with page regeneration."}