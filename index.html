<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Backbone.hoard by cmaher</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Backbone.hoard</h1>
        <p>XHR de-duping and configurable caching for Backbone.js</p>

        <p class="view"><a href="https://github.com/cmaher/backbone.hoard">View the Project on GitHub <small>cmaher/backbone.hoard</small></a></p>


        <ul>
          <li><a href="https://github.com/cmaher/backbone.hoard/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/cmaher/backbone.hoard/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/cmaher/backbone.hoard">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p><a href="https://travis-ci.org/cmaher/backbone.hoard"><img src="https://travis-ci.org/cmaher/backbone.hoard.svg?branch=master" alt="Build Status"></a></p>

<h2>
<a id="backbonehoard" class="anchor" href="#backbonehoard" aria-hidden="true"><span class="octicon octicon-link"></span></a>backbone.hoard</h2>

<p><a href="https://gitter.im/cmaher/backbone.hoard?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Gitter"></a></p>

<p>Configurable caching for Backbone. Hoard is designed to make it easy to avoid 
extraneous AJAX requests by caching responses and making sure only one request goes out for the same url, 
all while remaining highly configurable and customizable. <a href="http://www.conductor.com/nightlight/using-backbone-hoard-spare-server-sanity/">Read about the reasoning behind Backbone.Hoard to find out if it's right for you</a>.</p>

<h1>
<a id="installing" class="anchor" href="#installing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installing</h1>

<p>Hoard is available on npm and bower as <code>backbone.hoard</code>.</p>

<pre><code>npm install backbone.hoard

OR

bower install backbone.hoard
</code></pre>

<p>When using bower, <code>dist/backbone.hoard.js</code> should work for all environments.</p>

<h1>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h1>

<div class="highlight highlight-js"><pre><span class="pl-s">var</span> cacheControl <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Backbone.Hoard</span>.Control();
<span class="pl-s">var</span> MyModel <span class="pl-k">=</span> Backbone.Model.extend({
    <span class="pl-en">url</span>: <span class="pl-st">function</span> () {
        <span class="pl-k">return</span> <span class="pl-s1"><span class="pl-pds">'</span>/my-models/<span class="pl-pds">'</span></span> <span class="pl-k">+</span> <span class="pl-v">this</span>.<span class="pl-sc">id</span>;
    },

    sync<span class="pl-k">:</span> cacheControl.getModelSync()
});

<span class="pl-s">var</span> model1 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyModel</span>({ id<span class="pl-k">:</span> <span class="pl-c1">1</span> });
<span class="pl-s">var</span> model2 <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyModel</span>({ id<span class="pl-k">:</span> <span class="pl-c1">1</span> });

<span class="pl-s">var</span> fetches <span class="pl-k">=</span> [model1.fetch(), model2.fetch()];

Promise.<span class="pl-sc">all</span>(fetches).then(<span class="pl-st">function</span> () {
    <span class="pl-c">// model1 and model2 have the same attributes, returned from the endpoint</span>
    <span class="pl-c">// Only one ajax request has been made</span>
    doStuff();
});</pre></div>

<h1>
<a id="requirements" class="anchor" href="#requirements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements</h1>

<ul>
<li>Backbone 1.0.0 - 1.1.2</li>
<li>underscore 1.4.4 - 1.7.0</li>
<li><code>localStorage</code></li>
<li>An es6-compliant <code>Promise</code>
</li>
</ul>

<h1>
<a id="api" class="anchor" href="#api" aria-hidden="true"><span class="octicon octicon-link"></span></a>API</h1>

<p>The usage demonstrated in the example represents the common use case. 
That said, Hoard is about configuring caching behavior, and each component is open to customization.</p>

<h2>
<a id="control" class="anchor" href="#control" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control</h2>

<p>The <code>Control</code> is the entry point for all Hoard behavior. 
It's primary purpose is to assemble a <code>Strategy</code> for each method accepted by Backbone.sync.</p>

<h3>
<a id="new-controloptions" class="anchor" href="#new-controloptions" aria-hidden="true"><span class="octicon octicon-link"></span></a>new Control(options)</h3>

<p>Creates a <code>Control</code> and overwrites the following default options, if provided</p>

<ul>
<li>storeClass: the type of <code>Store</code> to create and assign to <code>store</code>, passed to all strategies</li>
<li>policyClass: the type of <code>Policy</code> to create and assign to <code>policy</code>, passed to all strategies</li>
<li>createStrategyClass: the type of <code>Strategy</code> to create and assign to <code>createStrategy</code>, used when <code>sync</code> is called with method <code>create</code>
</li>
<li>readStrategyClass: the type of <code>Strategy</code> to create and assign to <code>readStrategy</code>, used when <code>sync</code> is called with method <code>read</code>
</li>
<li>updateStrategyClass: the type of <code>Strategy</code> to create and assign to <code>updateStrategy</code>, used when <code>sync</code> is called with method <code>update</code>
</li>
<li>deleteStrategyClass: the type of <code>Strategy</code> to create and assign to <code>deleteStrategy</code>, used when <code>sync</code> is called with method <code>delete</code>
</li>
<li>patchStrategyClass: the type of <code>Strategy</code> to create and assign to <code>patchStrategy</code>, used when <code>sync</code> is called with method <code>patch</code>
</li>
</ul>

<p>All options provided will be passed down to the constructors of the <code>store</code>, <code>policy</code>, and all strategies.</p>

<h3>
<a id="controlsyncmethod-model-options" class="anchor" href="#controlsyncmethod-model-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control#sync(method, model, options)</h3>

<p>Delegates to a strategy determined by <code>method</code>. Calls <code>Strategy#execute</code> with the provided <code>model</code> and <code>options</code>.</p>

<p>Returns a <code>Promise</code> that resolves if the sync action is successful or rejects if it fails.</p>

<p>By default, Control#sync behaves differently depending on the <code>method</code> parameter, as follows:</p>

<ul>
<li>
<code>read</code>

<ul>
<li>[Cache hit] If the given <code>model</code> has data in the cache

<ul>
<li>If the item is not expired, call options.success with the cached item</li>
<li>If the item is expired, remove the item from the cache, and proceed as a read [Cache Miss]</li>
</ul>
</li>
<li>[Cache Miss] If the given <code>model</code> does not have data in the cache

<ul>
<li>On a success, store the result in the cache</li>
<li>On an error, remove the <code>model</code>'s item from the cache</li>
<li>While waiting for the result of the call to <code>Backbone.sync</code>, prevent subsequent requests to the same url 
from being made. Update all models blocked in this way once the <code>sync</code> result is known.</li>
</ul>
</li>
</ul>
</li>
<li>
<code>create</code>, <code>update</code>, <code>patch</code>

<ul>
<li>Delegate to <code>Backbone.sync</code> and store the response in the cache</li>
</ul>
</li>
<li>
<code>delete</code>

<ul>
<li>Remove the <code>model</code>'s item from the cache</li>
<li>Delegate to <code>Backbone.sync</code>
</li>
</ul>
</li>
</ul>

<p>All interactions with the cache use the given <code>model</code>'s <code>url</code> property as th key, 
as resolved at time of the initial sync call</p>

<p>NOTE: If at any time there is not enough space in the cache to store the desired item, Hoard will remove all 
managed items from the cache and try again. This behavior is temporary and is targeted for improvment in future releases.</p>

<h3>
<a id="controlgetmodelsync" class="anchor" href="#controlgetmodelsync" aria-hidden="true"><span class="octicon octicon-link"></span></a>Control#getModelSync</h3>

<p>Returns a method that can be assigned <code>sync</code> on a <code>Backbone.Model</code> or a <code>Backbone.Collection</code>. 
The returned method has all of the same properties as the control's <code>sync</code> method.</p>

<h2>
<a id="policy" class="anchor" href="#policy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy</h2>

<p>The <code>Policy</code> determines meta information about cached items</p>

<h3>
<a id="policytimetolive" class="anchor" href="#policytimetolive" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#timeToLive</h3>

<p>The amount of time, in milliseconds, that an item should be stored in the cache</p>

<h3>
<a id="policyexpires" class="anchor" href="#policyexpires" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#expires</h3>

<p>A timestamp, in milliseconds, indicating the time after which the item should no longer be stored in the cache. 
If both <code>timeToLive</code> and <code>expires</code> are present, <code>expires</code> takes precedence.</p>

<h3>
<a id="policygeturlmodel-options-options" class="anchor" href="#policygeturlmodel-options-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#getUrl(model, options, options)</h3>

<p>Returns an identifier for the given <code>model</code> and <code>method</code> to reference in the cache.
Defaults to the result of <code>model.url</code>.</p>

<h3>
<a id="policygetkeymodel-method-options" class="anchor" href="#policygetkeymodel-method-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#getKey(model, method, options)</h3>

<p>Returns an identifier for the given <code>model</code> and <code>method</code> to reference in the cache.
Defaults to Policy#getUrl.</p>

<h3>
<a id="policygetdatamodel-options" class="anchor" href="#policygetdatamodel-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#getData(model, options)</h3>

<p>Return the database representation of the model. Defaults to <code>model.toJSON()</code>.</p>

<h3>
<a id="policyshouldevictitemmetadata" class="anchor" href="#policyshouldevictitemmetadata" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#shouldEvictItem(metadata)</h3>

<p>Returns <code>true</code> if the item represented by <code>metadata</code> is stale, false otherwise.</p>

<h3>
<a id="policygetkeystoevictmetadata-key-value-error" class="anchor" href="#policygetkeystoevictmetadata-key-value-error" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#getKeysToEvict(metadata, key, value, error)</h3>

<p>Returns an array of keys to evict from cache if the cache is full. Defaults to returning all keys in the cache.</p>

<h3>
<a id="policygetmetadatakey-response-options" class="anchor" href="#policygetmetadatakey-response-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Policy#getMetadata(key, response, [options])</h3>

<p>Returns an object representing the metadata for the given <code>key</code>, <code>response</code>, and <code>options</code>.</p>

<p>By default, only expiration data is returned, based on the Policy's <code>timeToLive</code> or <code>expires</code> property. 
This behavior is agnostic of any arguments provided, which are available for custom implementations.</p>

<h2>
<a id="strategy" class="anchor" href="#strategy" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strategy</h2>

<p>The <code>Strategy</code> uses the <code>Store</code> and <code>Policy</code> to determines how to handle any given call to <code>sync</code>. It is responsible for
determining when to read from the cache or from the server, when to write to the cache, 
and when to remove items from the cache.</p>

<h3>
<a id="strategyexecutemodel-options" class="anchor" href="#strategyexecutemodel-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Strategy#execute(model, options)</h3>

<p>Determines how to handle a <code>sync</code> for the given <code>model</code>. The bulk of caching behavior is handled by various 
implementations of this method in different subclasses of <code>Strategy</code></p>

<p>Returns a <code>Promise</code> that resolves if the sync action is successful or rejects if it fails.</p>

<h2>
<a id="store" class="anchor" href="#store" aria-hidden="true"><span class="octicon octicon-link"></span></a>Store</h2>

<p>The <code>Store</code> encapsulates all interaction with the backing persistence API. 
Even though the default implementation uses <code>localStorage</code> for persistence, 
all interactions with <code>Store</code> are asynchronous. 
This behavior makes it possible to use other types of client-side storage, such as IndexedDB or WebSQL</p>

<h3>
<a id="storegetkey-options" class="anchor" href="#storegetkey-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Store#get(key, [options])</h3>

<p>Returns a <code>Promise</code> that resolves with the cached item associated with the given <code>key</code> if it exists, 
or a rejected <code>Promise</code> if the item is not in the cache.</p>

<p><code>options</code> are provided for use by custom implementations.</p>

<h3>
<a id="storesetkey-item-meta-options" class="anchor" href="#storesetkey-item-meta-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Store#set(key, item, meta, [options])</h3>

<p>Store the given <code>item</code> in the cache under the given <code>key</code>. 
Additionally, store the provided <code>metadata</code> containing information that Hoard needs to manage the cached item.</p>

<p>Returns a <code>Promise</code> that resolves when the given item and metadata are stored
or rejects if an error occurs when storing either value.</p>

<p><code>options</code> are provided for use by custom implementations.</p>

<h3>
<a id="storeinvalidatekey-options" class="anchor" href="#storeinvalidatekey-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Store#invalidate(key, [options])</h3>

<p>Remove the item and metadata associated with the given <code>key</code> from the cache.</p>

<p>Returns a <code>Promise</code> that resolves when the item is removed from the cache.</p>

<p><code>options</code> are provided for use by custom implementations.</p>

<h3>
<a id="storegetmetadatakey-options" class="anchor" href="#storegetmetadatakey-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Store#getMetadata(key, [options])</h3>

<p>Returns a <code>Promise</code> that resolves with either the metadata associated with the given <code>key</code> 
or an empty object if no metadata is found.</p>

<p><code>options</code> are provided for use by custom implementations.</p>

<h1>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h1>

<p>Hoard uses reasonable defaults for it's external dependencies, but they can be configured, if desired.</p>

<h2>
<a id="hoardpromise" class="anchor" href="#hoardpromise" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hoard.Promise</h2>

<p>Hoard will use the native Promise (<code>window.Promise</code>) implementation, if it exists. 
Otherwise, you will need to configure Hoard with an es6-compliant Promise implementation.</p>

<h2>
<a id="hoardbackend" class="anchor" href="#hoardbackend" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hoard.backend</h2>

<p>By default, Hoard will use <code>localStorage</code> to cache data and metadata.
If support for older browsers is desired, be sure to use a polyfill. 
<code>Hoard.backend</code> can also be set to <code>sessionStorage</code>, or anything matching a <code>localStorage</code> API supporting:</p>

<ul>
<li><code>backend.setItem</code></li>
<li><code>backend.getItem</code></li>
<li>
<p><code>backend.removeItem</code></p>

<div class="highlight highlight-js"><pre><span class="pl-c">// ex: using sessionStorage instead of local storage</span>
<span class="pl-c">// Make Stores use sessionStorage unless explicitly told to use something else</span>
Hoard.backend <span class="pl-k">=</span> sessionStorage;

<span class="pl-c">// Make all instantces of LocalStore use localStorage</span>
<span class="pl-s">var</span> LocalStore <span class="pl-k">=</span> Hoard.Store.extend({ backend<span class="pl-k">:</span> localStorage });</pre></div>
</li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/cmaher">cmaher</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-38761388-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>